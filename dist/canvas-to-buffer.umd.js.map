{"version":3,"file":"canvas-to-buffer.umd.js","sources":["../src/index.ts"],"sourcesContent":["import toBuffer from \"typedarray-to-buffer\";\nimport atob from \"atob\";\nimport { Canvas } from \"canvas\";\nconst isBrowser =\n  typeof document !== \"undefined\" && typeof document.createElement === \"function\";\n\nconst defaultTypes = isBrowser ? [\"webp\", \"jpeg\"] : [\"png\"];\n\ntype MimeType = \"image/png\" | \"image/jpeg\" | \"image/webp\";\n\n// cached, used only once for browser environments\nlet verifiedMimeType: MimeType | undefined;\n\nclass Frame {\n  private quality: number;\n  private types: string[];\n  private canvas: Canvas;\n  // For Unit tests\n  static atob?: (str: string) => string;\n\n  constructor(canvas: Canvas, types = defaultTypes, quality = 0.5) {\n    // validate some options this class needs\n\n    if (types.length > 2) {\n      throw new Error(\"Too many image types are specified!\");\n    }\n\n    this.canvas = canvas;\n    this.quality = quality;\n    this.types = types;\n  }\n\n  private composeMimeType(index: number) {\n    let mimeType: MimeType | undefined;\n\n    if (this.types[index]) {\n      mimeType = \"image/\" + this.types[index];\n    }\n\n    return mimeType;\n  }\n\n  private isMatch(uri: string, imageType: string) {\n    return uri.match(imageType);\n  }\n\n  // Performance tweak, we do not need a big canvas for finding out the supported image type\n  private getTestCanvas() {\n    let testCanvas;\n\n    if (isBrowser) {\n      testCanvas = document.createElement(\"canvas\");\n      testCanvas.width = testCanvas.height = 1;\n    } else {\n      testCanvas = this.canvas;\n    }\n\n    return testCanvas;\n  }\n\n  private canvasSupportsMimeType(mimeType: string) {\n    try {\n      const testCanvas = this.getTestCanvas();\n      const uri = testCanvas.toDataURL && testCanvas.toDataURL(mimeType);\n\n      return this.isMatch(uri, mimeType);\n    } catch (exc) {\n      // Can happen when i.E. a spider is coming. Just be robust here and continue.\n      return false;\n    }\n  }\n\n  private figureMimeType() {\n    let mimeType: MimeType | undefined = this.composeMimeType(0);\n\n    if (!mimeType || !this.canvasSupportsMimeType(mimeType)) {\n      if (this.types[1]) {\n        mimeType = this.composeMimeType(1);\n\n        if (mimeType && !this.canvasSupportsMimeType(mimeType)) {\n          mimeType = undefined;\n        }\n      } else {\n        mimeType = undefined;\n      }\n    }\n\n    return mimeType;\n  }\n\n  // this method is proven to be fast, see\n  // http://jsperf.com/data-uri-to-buffer-performance/3\n  private uriToBuffer(uri: string) {\n    const uriSplitted = uri.split(\",\")[1];\n    let bytes: string;\n\n    if (!uriSplitted) {\n      throw new Error(\"Empty uri string given!\");\n    } else if (typeof atob === \"function\") {\n      // Beware that the atob function might be a static one for server side tests\n      bytes = atob(uriSplitted);\n    } else {\n      throw new Error(\"atob function is missing\");\n    }\n\n    const arr = new Uint8Array(bytes.length);\n\n    // http://mrale.ph/blog/2014/12/24/array-length-caching.html\n    for (let i = 0, l = bytes.length; i < l; i++) {\n      arr[i] = bytes.charCodeAt(i);\n    }\n\n    return toBuffer(arr);\n  }\n\n  public toBuffer() {\n    const mimeType = this.getMimeType();\n    let buffer;\n\n    if (mimeType) {\n      const uri = this.canvas.toDataURL(mimeType as \"image/jpeg\", this.quality);\n      buffer = this.uriToBuffer(uri);\n    }\n\n    return buffer;\n  }\n\n  public getMimeType() {\n    // on the browser side we do cache it for speed\n    if (!verifiedMimeType || !isBrowser) {\n      verifiedMimeType = this.figureMimeType();\n    }\n\n    return verifiedMimeType;\n  }\n}\n\nexport default Frame;\n"],"names":["verifiedMimeType","isBrowser","document","createElement","defaultTypes","Frame","canvas","types","quality","length","Error","this","_proto","prototype","composeMimeType","index","mimeType","isMatch","uri","imageType","match","getTestCanvas","testCanvas","width","height","canvasSupportsMimeType","toDataURL","exc","figureMimeType","undefined","uriToBuffer","bytes","uriSplitted","split","atob","arr","Uint8Array","i","l","charCodeAt","toBuffer","buffer","getMimeType"],"mappings":"0ZAWIA,0CAREC,EACgB,oBAAbC,UAA8D,mBAA3BA,SAASC,cAE/CC,EAAeH,EAAY,CAAC,OAAQ,QAAU,CAAC,OAO/CI,eAOJ,WAAA,SAAAA,EAAYC,EAAgBC,EAAsBC,GAGhD,YAH0BD,IAAAA,EAAQH,QAAcI,IAAAA,IAAAA,EAAU,IANpDA,KAAAA,aACAD,EAAAA,KAAAA,kBACAD,YAAM,EAORC,EAAME,OAAS,EACjB,MAAU,IAAAC,MAAM,uCAGlBC,KAAKL,OAASA,EACdK,KAAKH,QAAUA,EACfG,KAAKJ,MAAQA,CACf,CAAC,IAAAK,EAAAP,EAAAQ,UAwGA,OAxGAD,EAEOE,gBAAA,SAAgBC,GACtB,IAAIC,EAMJ,OAJIL,KAAKJ,MAAMQ,KACbC,EAAW,SAAWL,KAAKJ,MAAMQ,IAG5BC,CACT,EAACJ,EAEOK,QAAA,SAAQC,EAAaC,GAC3B,OAAOD,EAAIE,MAAMD,EACnB,EAACP,EAGOS,cAAA,WACN,IAAIC,EASJ,OAPIrB,GACFqB,EAAapB,SAASC,cAAc,WACzBoB,MAAQD,EAAWE,OAAS,EAEvCF,EAAaX,KAAKL,OAGbgB,CACT,EAACV,EAEOa,uBAAA,SAAuBT,GAC7B,IACE,IAAMM,EAAaX,KAAKU,gBAClBH,EAAMI,EAAWI,WAAaJ,EAAWI,UAAUV,GAEzD,OAAOL,KAAKM,QAAQC,EAAKF,EAC3B,CAAE,MAAOW,GAEP,OAAO,CACT,CACF,EAACf,EAEOgB,eAAA,WACN,IAAIZ,EAAiCL,KAAKG,gBAAgB,GAc1D,OAZKE,GAAaL,KAAKc,uBAAuBT,KACxCL,KAAKJ,MAAM,IACbS,EAAWL,KAAKG,gBAAgB,MAEfH,KAAKc,uBAAuBT,KAC3CA,OAAWa,GAGbb,OAAWa,GAIRb,CACT,EAACJ,EAIOkB,YAAA,SAAYZ,GAClB,IACIa,EADEC,EAAcd,EAAIe,MAAM,KAAK,GAGnC,IAAKD,EACH,MAAM,IAAItB,MAAM,2BACP,GAAgB,mBAATwB,EAAAA,QAIhB,MAAU,IAAAxB,MAAM,4BAFhBqB,EAAQG,UAAKF,GAQf,IAHA,IAAMG,EAAM,IAAIC,WAAWL,EAAMtB,QAGxB4B,EAAI,EAAGC,EAAIP,EAAMtB,OAAQ4B,EAAIC,EAAGD,IACvCF,EAAIE,GAAKN,EAAMQ,WAAWF,GAG5B,OAAOG,EAAQ,QAACL,EAClB,EAACvB,EAEM4B,SAAA,WACL,IACIC,EADEzB,EAAWL,KAAK+B,cAGtB,GAAI1B,EAAU,CACZ,IAAME,EAAMP,KAAKL,OAAOoB,UAAUV,EAA0BL,KAAKH,SACjEiC,EAAS9B,KAAKmB,YAAYZ,EAC5B,CAEA,OAAOuB,CACT,EAAC7B,EAEM8B,YAAA,WAML,OAJK1C,GAAqBC,IACxBD,EAAmBW,KAAKiB,kBAGnB5B,CACT,EAACK,CAAA,CAlHD,UAPIA,EAKG6B,UAuHT"}