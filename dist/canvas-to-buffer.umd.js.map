{"version":3,"file":"canvas-to-buffer.umd.js","sources":["../src/index.ts"],"sourcesContent":["import toBuffer from \"typedarray-to-buffer\";\nimport { Canvas } from \"canvas\";\nconst isBrowser =\n  typeof document !== \"undefined\" && typeof document.createElement === \"function\";\n\nconst defaultTypes = isBrowser ? [\"webp\", \"jpeg\"] : [\"png\"];\n\ntype MimeType = \"image/png\" | \"image/jpeg\" | \"image/webp\";\n\n// cached, used only once for browser environments\nlet verifiedMimeType: MimeType | undefined;\n\nclass Frame {\n  private quality: number;\n  private types: string[];\n  private canvas: Canvas;\n  // For Unit tests\n  static atob?: (str: string) => string;\n\n  constructor(canvas: Canvas, types = defaultTypes, quality = 0.5) {\n    // validate some options this class needs\n\n    if (types.length > 2) {\n      throw new Error(\"Too many image types are specified!\");\n    }\n\n    this.canvas = canvas;\n    this.quality = quality;\n    this.types = types;\n  }\n\n  private composeMimeType(index: number) {\n    let mimeType: MimeType | undefined;\n\n    if (this.types[index]) {\n      mimeType = \"image/\" + this.types[index];\n    }\n\n    return mimeType;\n  }\n\n  private isMatch(uri: string, imageType: string) {\n    return uri.match(imageType);\n  }\n\n  // Performance tweak, we do not need a big canvas for finding out the supported image type\n  private getTestCanvas() {\n    let testCanvas;\n\n    if (isBrowser) {\n      testCanvas = document.createElement(\"canvas\");\n      testCanvas.width = testCanvas.height = 1;\n    } else {\n      testCanvas = this.canvas;\n    }\n\n    return testCanvas;\n  }\n\n  private canvasSupportsMimeType(mimeType: string) {\n    try {\n      const testCanvas = this.getTestCanvas();\n      const uri = testCanvas.toDataURL && testCanvas.toDataURL(mimeType);\n\n      return this.isMatch(uri, mimeType);\n    } catch (exc) {\n      // Can happen when i.E. a spider is coming. Just be robust here and continue.\n      return false;\n    }\n  }\n\n  private figureMimeType() {\n    let mimeType: MimeType | undefined = this.composeMimeType(0);\n\n    if (!mimeType || !this.canvasSupportsMimeType(mimeType)) {\n      if (this.types[1]) {\n        mimeType = this.composeMimeType(1);\n\n        if (mimeType && !this.canvasSupportsMimeType(mimeType)) {\n          mimeType = undefined;\n        }\n      } else {\n        mimeType = undefined;\n      }\n    }\n\n    return mimeType;\n  }\n\n  // this method is proven to be fast, see\n  // http://jsperf.com/data-uri-to-buffer-performance/3\n  private uriToBuffer(uri: string) {\n    const uriSplitted = uri.split(\",\")[1];\n    let bytes: string | undefined;\n\n    if (!uriSplitted) {\n      throw new Error(\"Empty uri string given!\");\n    } else if (isBrowser) {\n      bytes = window.atob(uriSplitted);\n    } else {\n      // Beware that the atob function might be a static one for server side tests\n      bytes = Frame.atob?.(uriSplitted);\n    }\n\n    if (!bytes) {\n      throw new Error(\"Byte are empty, something within atob went wrong.\");\n    }\n\n    const arr = new Uint8Array(bytes.length);\n\n    // http://mrale.ph/blog/2014/12/24/array-length-caching.html\n    for (let i = 0, l = bytes.length; i < l; i++) {\n      arr[i] = bytes.charCodeAt(i);\n    }\n\n    return toBuffer(arr);\n  }\n\n  public toBuffer() {\n    const mimeType = this.getMimeType();\n\n    let buffer;\n\n    if (mimeType) {\n      const uri = this.canvas.toDataURL(mimeType as \"image/jpeg\", this.quality);\n      buffer = this.uriToBuffer(uri);\n    }\n\n    return buffer;\n  }\n\n  public getMimeType() {\n    // on the browser side we do cache it for speed\n    if (!verifiedMimeType || !isBrowser) {\n      verifiedMimeType = this.figureMimeType();\n    }\n\n    return verifiedMimeType;\n  }\n}\n\nexport default Frame;\n"],"names":["verifiedMimeType","isBrowser","document","createElement","defaultTypes","Frame","canvas","types","quality","this","length","Error","_proto","prototype","composeMimeType","index","mimeType","isMatch","uri","imageType","match","getTestCanvas","testCanvas","width","height","canvasSupportsMimeType","toDataURL","exc","figureMimeType","undefined","uriToBuffer","bytes","uriSplitted","split","window","atob","arr","Uint8Array","i","l","charCodeAt","toBuffer","buffer","getMimeType"],"mappings":"0XAUIA,sBAREC,EACgB,oBAAbC,UAA8D,mBAA3BA,SAASC,cAE/CC,EAAeH,EAAY,CAAC,OAAQ,QAAU,CAAC,OAO/CI,eAOJ,WAAA,SAAAA,EAAYC,EAAgBC,EAAsBC,GAGhD,QAH0BD,IAAAA,IAAAA,EAAQH,QAAqB,IAAPI,IAAAA,EAAU,IANpDA,KAAAA,oBACAD,WAAK,EAAAE,KACLH,YAAM,EAORC,EAAMG,OAAS,EACjB,MAAU,IAAAC,MAAM,uCAGlBF,KAAKH,OAASA,EACdG,KAAKD,QAAUA,EACfC,KAAKF,MAAQA,CACf,CAAC,IAAAK,EAAAP,EAAAQ,UA6GA,OA7GAD,EAEOE,gBAAA,SAAgBC,GACtB,IAAIC,EAMJ,OAJIP,KAAKF,MAAMQ,KACbC,EAAW,SAAWP,KAAKF,MAAMQ,IAG5BC,CACT,EAACJ,EAEOK,QAAA,SAAQC,EAAaC,GAC3B,OAAOD,EAAIE,MAAMD,EACnB,EAACP,EAGOS,cAAA,WACN,IAAIC,EASJ,OAPIrB,GACFqB,EAAapB,SAASC,cAAc,WACzBoB,MAAQD,EAAWE,OAAS,EAEvCF,EAAab,KAAKH,OAGbgB,CACT,EAACV,EAEOa,uBAAA,SAAuBT,GAC7B,IACE,IAAMM,EAAab,KAAKY,gBAClBH,EAAMI,EAAWI,WAAaJ,EAAWI,UAAUV,GAEzD,OAAWP,KAACQ,QAAQC,EAAKF,EAC3B,CAAE,MAAOW,GAEP,OAAO,CACT,CACF,EAACf,EAEOgB,eAAA,WACN,IAAIZ,EAAiCP,KAAKK,gBAAgB,GAc1D,OAZKE,GAAaP,KAAKgB,uBAAuBT,KACxCP,KAAKF,MAAM,IACbS,EAAWP,KAAKK,gBAAgB,MAEfL,KAAKgB,uBAAuBT,KAC3CA,OAAWa,GAGbb,OAAWa,GAIRb,CACT,EAACJ,EAIOkB,YAAA,SAAYZ,GAClB,IACIa,EADEC,EAAcd,EAAIe,MAAM,KAAK,GAGnC,IAAKD,EACH,UAAUrB,MAAM,2BAQlB,KANEoB,EADS9B,EACDiC,OAAOC,KAAKH,GAGF,MAAV3B,EAAM8B,UAAI,EAAV9B,EAAM8B,KAAOH,IAIrB,MAAM,IAAIrB,MAAM,qDAMlB,IAHA,IAAMyB,EAAM,IAAIC,WAAWN,EAAMrB,QAGxB4B,EAAI,EAAGC,EAAIR,EAAMrB,OAAQ4B,EAAIC,EAAGD,IACvCF,EAAIE,GAAKP,EAAMS,WAAWF,GAG5B,OAAOG,UAASL,EAClB,EAACxB,EAEM6B,SAAA,WACL,IAEIC,EAFE1B,EAAWP,KAAKkC,cAItB,GAAI3B,EAAU,CACZ,IAAME,EAAMT,KAAKH,OAAOoB,UAAUV,EAA0BP,KAAKD,SACjEkC,EAASjC,KAAKqB,YAAYZ,EAC5B,CAEA,OAAOwB,CACT,EAAC9B,EAEM+B,YAAA,WAML,OAJK3C,GAAqBC,IACxBD,EAAmBS,KAAKmB,kBAGnB5B,CACT,EAACK,CAAA,CAvHD,UAPIA,EAKG8B,UA4HT"}