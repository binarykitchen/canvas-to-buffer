{"version":3,"file":"canvas-to-buffer.umd.js","sources":["../index.js"],"sourcesContent":["const toBuffer = require('typedarray-to-buffer')\nconst atob = require('atob')\nconst isBrowser = typeof document !== 'undefined' && typeof document.createElement === 'function'\n\n// cached, used only once for browser environments\nvar verifiedImageType\n\nmodule.exports = function (canvas, options) {\n  const self = this\n\n  options = options || {}\n  options.image = options.image ? options.image : {}\n  options.image.types = options.image.types ? options.image.types : []\n\n  // validate some options this class needs\n  if (options.image.types.length > 2) {\n    throw new Error('Too many image types are specified!')\n  } else if (options.image.types.length < 1) {\n    // Set a default image type, just to be robust\n    options.image.types = isBrowser ? ['webp', 'jpeg'] : ['png']\n  }\n\n  if (!options.image.quality) {\n    options.image.quality = 0.5 // default\n  }\n\n  const quality = parseFloat(options.image.quality)\n\n  function composeImageType (index) {\n    var imageType\n\n    if (options.image.types[index]) {\n      imageType = 'image/' + options.image.types[index]\n    }\n\n    return imageType\n  }\n\n  function isMatch (uri, imageType) {\n    const match = uri && uri.match(imageType)\n\n    match && options.debug && options.debug('Image type %s verified', imageType)\n\n    return match\n  }\n\n  // Performance tweak, we do not need a big canvas for finding out the supported image type\n  function getTestCanvas () {\n    var testCanvas\n\n    if (isBrowser) {\n      testCanvas = document.createElement('canvas')\n      testCanvas.width = testCanvas.height = 1\n    } else {\n      testCanvas = canvas\n    }\n\n    return testCanvas\n  }\n\n  function canvasSupportsImageTypeAsync (imageType, cb) {\n    try {\n      getTestCanvas().toDataURL(imageType, function (err, uri) {\n        if (err) {\n          cb(err)\n        } else {\n          cb(null, isMatch(uri, imageType))\n        }\n      })\n    } catch (exc) {\n      cb(null, false)\n    }\n  }\n\n  function canvasSupportsImageTypeSync (imageType) {\n    var match\n\n    try {\n      const testCanvas = getTestCanvas()\n      const uri = testCanvas.toDataURL && testCanvas.toDataURL(imageType)\n\n      match = isMatch(uri, imageType)\n    } catch (exc) {\n      // Can happen when i.E. a spider is coming. Just be robust here and continue.\n      options.debug &&\n      options.logger.debug('Failed to call toDataURL() on canvas for image type %s', imageType)\n    }\n\n    return match\n  }\n\n  function verifyImageTypeAsync (imageType, cb) {\n    canvasSupportsImageTypeAsync(imageType, function (err, match) {\n      if (err) {\n        cb(err)\n      } else {\n        if (match) {\n          cb(null, imageType)\n        } else {\n          imageType = composeImageType(1)\n\n          canvasSupportsImageTypeAsync(imageType, function (err, match) {\n            if (err) {\n              cb(err)\n            } else {\n              cb(null, match ? imageType : null)\n            }\n          })\n        }\n      }\n    })\n  }\n\n  function verifyImageTypeSync (imageType) {\n    if (!canvasSupportsImageTypeSync(imageType)) {\n      if (options.image.types[1]) {\n        imageType = composeImageType(1)\n\n        if (!canvasSupportsImageTypeSync(imageType)) {\n          imageType = null\n        }\n      } else {\n        imageType = null\n      }\n    }\n\n    !imageType && options.debug && options.logger.debug('Unable to verify image type')\n\n    return imageType\n  }\n\n  // callbacks are needed for server side tests\n  function verifyImageType (cb) {\n    const imageType = composeImageType(0)\n\n    if (cb) {\n      verifyImageTypeAsync(imageType, cb)\n    } else {\n      return verifyImageTypeSync(imageType)\n    }\n  }\n\n  // this method is proven to be fast, see\n  // http://jsperf.com/data-uri-to-buffer-performance/3\n  function uriToBuffer (uri) {\n    const uriSplitted = uri.split(',')[1]\n    var bytes\n\n    // Beware that the atob function might be a static one for server side tests\n    if (typeof (atob) === 'function') {\n      bytes = atob(uriSplitted)\n    } else if (typeof (self.constructor.atob) === 'function') {\n      bytes = self.constructor.atob(uriSplitted)\n    } else {\n      throw new Error('atob function is missing')\n    }\n\n    const arr = new Uint8Array(bytes.length)\n\n    // http://mrale.ph/blog/2014/12/24/array-length-caching.html\n    for (var i = 0, l = bytes.length; i < l; i++) {\n      arr[i] = bytes.charCodeAt(i)\n    }\n\n    return toBuffer(arr)\n  }\n\n  function toBufferSync () {\n    const imageType = self.getImageType()\n    var buffer\n\n    if (imageType) {\n      const uri = canvas.toDataURL(imageType, quality)\n      buffer = uriToBuffer(uri)\n    }\n\n    return buffer\n  }\n\n  function toBufferAsync (cb) {\n    self.getImageType(function (err, imageType) {\n      if (err) {\n        cb(err)\n      } else if (!imageType) {\n        cb()\n      } else {\n        canvas.toDataURL(imageType, function (err, uri) {\n          if (err) {\n            cb(err)\n          } else {\n            cb(null, uriToBuffer(uri))\n          }\n        })\n      }\n    })\n  }\n\n  this.toBuffer = function (cb) {\n    if (cb) {\n      toBufferAsync(cb)\n    } else {\n      return toBufferSync()\n    }\n  }\n\n  // browsers do not need a callback, but tests do\n  this.getImageType = function (cb) {\n    // only run for the first time this constructor is called and\n    // cache result for the next calls\n    if (cb) {\n      if (!verifiedImageType || !isBrowser) {\n        verifyImageType(function (err, newVerifiedImageType) {\n          if (err) {\n            cb(err)\n          } else {\n            verifiedImageType = newVerifiedImageType\n            cb(null, verifiedImageType)\n          }\n        })\n      } else {\n        cb(null, verifiedImageType)\n      }\n    } else {\n      // on the browser side we do cache it for speed\n      if (!verifiedImageType || !isBrowser) {\n        verifiedImageType = verifyImageType()\n      }\n\n      return verifiedImageType\n    }\n  }\n}\n"],"names":["const","verifiedImageType","toBuffer","require","atob","isBrowser","document","createElement","module","exports","canvas","options","self","this","image","types","length","Error","quality","parseFloat","composeImageType","index","imageType","isMatch","uri","match","debug","getTestCanvas","testCanvas","width","height","canvasSupportsImageTypeAsync","cb","toDataURL","err","exc","canvasSupportsImageTypeSync","logger","verifyImageType","verifyImageTypeSync","verifyImageTypeAsync","uriToBuffer","bytes","uriSplitted","split","constructor","arr","Uint8Array","i","l","charCodeAt","getImageType","buffer","toBufferAsync","newVerifiedImageType"],"mappings":"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"}