{"version":3,"file":"canvas-to-buffer.mjs","sources":["../src/index.js"],"sourcesContent":["import toBuffer from \"typedarray-to-buffer\";\nimport atob from \"atob\";\nconst isBrowser =\n  typeof document !== \"undefined\" && typeof document.createElement === \"function\";\n\n// cached, used only once for browser environments\nlet verifiedImageType;\n\nconst Frame = function (canvas, options = {}) {\n  const self = this;\n\n  options.image = options.image ? options.image : {};\n  options.image.types = options.image.types ? options.image.types : [];\n\n  // validate some options this class needs\n  if (options.image.types.length > 2) {\n    throw new Error(\"Too many image types are specified!\");\n  } else if (options.image.types.length < 1) {\n    // Set a default image type, just to be robust\n    options.image.types = isBrowser ? [\"webp\", \"jpeg\"] : [\"png\"];\n  }\n\n  if (!options.image.quality) {\n    options.image.quality = 0.5; // default\n  }\n\n  const quality = parseFloat(options.image.quality);\n\n  function composeImageType(index) {\n    let imageType;\n\n    if (options.image.types[index]) {\n      imageType = \"image/\" + options.image.types[index];\n    }\n\n    return imageType;\n  }\n\n  function isMatch(uri, imageType) {\n    const match = uri && uri.match(imageType);\n\n    match && options.debug && options.debug(\"Image type %s verified\", imageType);\n\n    return match;\n  }\n\n  // Performance tweak, we do not need a big canvas for finding out the supported image type\n  function getTestCanvas() {\n    let testCanvas;\n\n    if (isBrowser) {\n      testCanvas = document.createElement(\"canvas\");\n      testCanvas.width = testCanvas.height = 1;\n    } else {\n      testCanvas = canvas;\n    }\n\n    return testCanvas;\n  }\n\n  function canvasSupportsImageTypeAsync(imageType, cb) {\n    try {\n      const testCanvas = getTestCanvas();\n      testCanvas.toDataURL(imageType, function (err, uri) {\n        if (err) {\n          cb(err);\n        } else {\n          cb(null, isMatch(uri, imageType));\n        }\n      });\n    } catch (exc) {\n      cb(null, false);\n    }\n  }\n\n  function canvasSupportsImageTypeSync(imageType) {\n    let match;\n\n    try {\n      const testCanvas = getTestCanvas();\n      const uri = testCanvas.toDataURL && testCanvas.toDataURL(imageType);\n\n      match = isMatch(uri, imageType);\n    } catch (exc) {\n      // Can happen when i.E. a spider is coming. Just be robust here and continue.\n      options.debug &&\n        options.logger.debug(\n          \"Failed to call toDataURL() on canvas for image type %s\",\n          imageType,\n        );\n    }\n\n    return match;\n  }\n\n  function verifyImageTypeAsync(imageType, cb) {\n    canvasSupportsImageTypeAsync(imageType, function (err, match) {\n      if (err) {\n        cb(err);\n      } else {\n        if (match) {\n          cb(null, imageType);\n        } else {\n          imageType = composeImageType(1);\n\n          canvasSupportsImageTypeAsync(imageType, function (err, match) {\n            if (err) {\n              cb(err);\n            } else {\n              cb(null, match ? imageType : null);\n            }\n          });\n        }\n      }\n    });\n  }\n\n  function verifyImageTypeSync(imageType) {\n    if (!canvasSupportsImageTypeSync(imageType)) {\n      if (options.image.types[1]) {\n        imageType = composeImageType(1);\n\n        if (!canvasSupportsImageTypeSync(imageType)) {\n          imageType = null;\n        }\n      } else {\n        imageType = null;\n      }\n    }\n\n    !imageType && options.debug && options.logger.debug(\"Unable to verify image type\");\n\n    return imageType;\n  }\n\n  // callbacks are needed for server side tests\n  function verifyImageType(cb) {\n    const imageType = composeImageType(0);\n\n    if (cb) {\n      verifyImageTypeAsync(imageType, cb);\n    } else {\n      return verifyImageTypeSync(imageType);\n    }\n  }\n\n  // this method is proven to be fast, see\n  // http://jsperf.com/data-uri-to-buffer-performance/3\n  function uriToBuffer(uri) {\n    const uriSplitted = uri.split(\",\")[1];\n    let bytes;\n\n    // Beware that the atob function might be a static one for server side tests\n    if (typeof atob === \"function\") {\n      bytes = atob(uriSplitted);\n    } else if (typeof self.constructor.atob === \"function\") {\n      bytes = self.constructor.atob(uriSplitted);\n    } else {\n      throw new Error(\"atob function is missing\");\n    }\n\n    const arr = new Uint8Array(bytes.length);\n\n    // http://mrale.ph/blog/2014/12/24/array-length-caching.html\n    for (let i = 0, l = bytes.length; i < l; i++) {\n      arr[i] = bytes.charCodeAt(i);\n    }\n\n    return toBuffer(arr);\n  }\n\n  function toBufferSync() {\n    const imageType = self.getImageType();\n    let buffer;\n\n    if (imageType) {\n      const uri = canvas.toDataURL(imageType, quality);\n      buffer = uriToBuffer(uri);\n    }\n\n    return buffer;\n  }\n\n  function toBufferAsync(cb) {\n    self.getImageType(function (err, imageType) {\n      if (err) {\n        cb(err);\n      } else if (!imageType) {\n        cb();\n      } else {\n        canvas.toDataURL(imageType, function (err, uri) {\n          if (err) {\n            cb(err);\n          } else {\n            cb(null, uriToBuffer(uri));\n          }\n        });\n      }\n    });\n  }\n\n  this.toBuffer = function (cb) {\n    if (cb) {\n      toBufferAsync(cb);\n    } else {\n      return toBufferSync();\n    }\n  };\n\n  // browsers do not need a callback, but tests do\n  this.getImageType = function (cb) {\n    // only run for the first time this constructor is called and\n    // cache result for the next calls\n    if (cb) {\n      if (!verifiedImageType || !isBrowser) {\n        verifyImageType(function (err, newVerifiedImageType) {\n          if (err) {\n            cb(err);\n          } else {\n            verifiedImageType = newVerifiedImageType;\n            cb(null, verifiedImageType);\n          }\n        });\n      } else {\n        cb(null, verifiedImageType);\n      }\n    } else {\n      // on the browser side we do cache it for speed\n      if (!verifiedImageType || !isBrowser) {\n        verifiedImageType = verifyImageType();\n      }\n\n      return verifiedImageType;\n    }\n  };\n};\n\nexport default Frame;\n"],"names":["verifiedImageType","isBrowser","document","createElement","Frame","canvas","options","self","this","image","types","length","Error","quality","parseFloat","composeImageType","index","imageType","isMatch","uri","match","debug","getTestCanvas","testCanvas","width","height","canvasSupportsImageTypeAsync","cb","toDataURL","err","exc","canvasSupportsImageTypeSync","logger","verifyImageType","verifyImageTypeSync","verifyImageTypeAsync","uriToBuffer","bytes","uriSplitted","split","atob","constructor","arr","Uint8Array","i","l","charCodeAt","toBuffer","getImageType","buffer","toBufferAsync","newVerifiedImageType"],"mappings":"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"}