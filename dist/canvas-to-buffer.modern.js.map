{"version":3,"file":"canvas-to-buffer.modern.js","sources":["../src/index.ts"],"sourcesContent":["import toBuffer from \"typedarray-to-buffer\";\nimport { Canvas } from \"canvas\";\nconst isBrowser =\n  typeof document !== \"undefined\" && typeof document.createElement === \"function\";\n\nconst defaultTypes = isBrowser ? [\"webp\", \"jpeg\"] : [\"png\"];\n\ntype MimeType = \"image/png\" | \"image/jpeg\" | \"image/webp\";\n\n// cached, used only once for browser environments\nlet verifiedMimeType: MimeType | undefined;\n\nclass Frame {\n  private quality: number;\n  private types: string[];\n  private canvas: Canvas;\n  // For Unit tests\n  static atob?: (str: string) => string;\n\n  constructor(canvas: Canvas, types = defaultTypes, quality = 0.5) {\n    // validate some options this class needs\n\n    if (types.length > 2) {\n      throw new Error(\"Too many image types are specified!\");\n    }\n\n    this.canvas = canvas;\n    this.quality = quality;\n    this.types = types;\n  }\n\n  private composeMimeType(index: number) {\n    let mimeType: MimeType | undefined;\n\n    if (this.types[index]) {\n      mimeType = \"image/\" + this.types[index];\n    }\n\n    return mimeType;\n  }\n\n  private isMatch(uri: string, imageType: string) {\n    return uri.match(imageType);\n  }\n\n  // Performance tweak, we do not need a big canvas for finding out the supported image type\n  private getTestCanvas() {\n    let testCanvas;\n\n    if (isBrowser) {\n      testCanvas = document.createElement(\"canvas\");\n      testCanvas.width = testCanvas.height = 1;\n    } else {\n      testCanvas = this.canvas;\n    }\n\n    return testCanvas;\n  }\n\n  private canvasSupportsMimeType(mimeType: string) {\n    try {\n      const testCanvas = this.getTestCanvas();\n      const uri = testCanvas.toDataURL && testCanvas.toDataURL(mimeType);\n\n      return this.isMatch(uri, mimeType);\n    } catch (exc) {\n      // Can happen when i.E. a spider is coming. Just be robust here and continue.\n      return false;\n    }\n  }\n\n  private figureMimeType() {\n    let mimeType: MimeType | undefined = this.composeMimeType(0);\n\n    if (!mimeType || !this.canvasSupportsMimeType(mimeType)) {\n      if (this.types[1]) {\n        mimeType = this.composeMimeType(1);\n\n        if (mimeType && !this.canvasSupportsMimeType(mimeType)) {\n          mimeType = undefined;\n        }\n      } else {\n        mimeType = undefined;\n      }\n    }\n\n    return mimeType;\n  }\n\n  // this method is proven to be fast, see\n  // http://jsperf.com/data-uri-to-buffer-performance/3\n  private uriToBuffer(uri: string) {\n    const uriSplitted = uri.split(\",\")[1];\n    let bytes: string | undefined;\n\n    if (!uriSplitted) {\n      throw new Error(\"Empty uri string given!\");\n    } else if (isBrowser) {\n      bytes = window.atob(uriSplitted);\n    } else {\n      // Beware that the atob function might be a static one for server side tests\n      bytes = Frame.atob?.(uriSplitted);\n    }\n\n    if (!bytes) {\n      throw new Error(\"Byte are empty, something within atob went wrong.\");\n    }\n\n    const arr = new Uint8Array(bytes.length);\n\n    // http://mrale.ph/blog/2014/12/24/array-length-caching.html\n    for (let i = 0, l = bytes.length; i < l; i++) {\n      arr[i] = bytes.charCodeAt(i);\n    }\n\n    return toBuffer(arr);\n  }\n\n  public toBuffer() {\n    const mimeType = this.getMimeType();\n\n    let buffer;\n\n    if (mimeType) {\n      const uri = this.canvas.toDataURL(mimeType as \"image/jpeg\", this.quality);\n      buffer = this.uriToBuffer(uri);\n    }\n\n    return buffer;\n  }\n\n  public getMimeType() {\n    // on the browser side we do cache it for speed\n    if (!verifiedMimeType || !isBrowser) {\n      verifiedMimeType = this.figureMimeType();\n    }\n\n    return verifiedMimeType;\n  }\n}\n\nexport default Frame;\n"],"names":["isBrowser","document","createElement","defaultTypes","verifiedMimeType","Frame","constructor","canvas","types","quality","this","length","Error","composeMimeType","index","mimeType","isMatch","uri","imageType","match","getTestCanvas","testCanvas","width","height","canvasSupportsMimeType","toDataURL","exc","figureMimeType","undefined","uriToBuffer","uriSplitted","split","bytes","window","atob","arr","Uint8Array","i","l","charCodeAt","toBuffer","getMimeType","buffer"],"mappings":"oCAEA,MAAMA,EACgB,oBAAbC,UAA8D,mBAA3BA,SAASC,cAE/CC,EAAeH,EAAY,CAAC,OAAQ,QAAU,CAAC,OAKrD,IAAII,EAEJ,MAAMC,EAOJC,WAAAA,CAAYC,EAAgBC,EAAQL,EAAcM,EAAU,IAG1D,GATMA,KAAAA,oBACAD,WAAK,EAAAE,KACLH,YAAM,EAORC,EAAMG,OAAS,EACjB,MAAM,IAAIC,MAAM,uCAGlBF,KAAKH,OAASA,EACdG,KAAKD,QAAUA,EACfC,KAAKF,MAAQA,CACf,CAEQK,eAAAA,CAAgBC,GACtB,IAAIC,EAMJ,OAJIL,KAAKF,MAAMM,KACbC,EAAW,SAAWL,KAAKF,MAAMM,IAG5BC,CACT,CAEQC,OAAAA,CAAQC,EAAaC,GAC3B,OAAOD,EAAIE,MAAMD,EACnB,CAGQE,aAAAA,GACN,IAAIC,EASJ,OAPIrB,GACFqB,EAAapB,SAASC,cAAc,UACpCmB,EAAWC,MAAQD,EAAWE,OAAS,GAEvCF,EAAaX,KAAKH,OAGbc,CACT,CAEQG,sBAAAA,CAAuBT,GAC7B,IACE,MAAMM,EAAaX,KAAKU,gBAClBH,EAAMI,EAAWI,WAAaJ,EAAWI,UAAUV,GAEzD,OAAOL,KAAKM,QAAQC,EAAKF,EAC3B,CAAE,MAAOW,GAEP,OACF,CAAA,CACF,CAEQC,cAAAA,GACN,IAAIZ,EAAiCL,KAAKG,gBAAgB,GAc1D,OAZKE,GAAaL,KAAKc,uBAAuBT,KACxCL,KAAKF,MAAM,IACbO,EAAWL,KAAKG,gBAAgB,GAE5BE,IAAaL,KAAKc,uBAAuBT,KAC3CA,OAAWa,IAGbb,OAAWa,GAIRb,CACT,CAIQc,WAAAA,CAAYZ,GAClB,MAAMa,EAAcb,EAAIc,MAAM,KAAK,GACnC,IAAIC,EAEJ,IAAKF,EACH,MAAU,IAAAlB,MAAM,2BAQlB,GANEoB,EADShC,EACDiC,OAAOC,KAAKJ,GAGF,MAAVzB,EAAM6B,UAAI,EAAV7B,EAAM6B,KAAOJ,IAGlBE,EACH,MAAU,IAAApB,MAAM,qDAGlB,MAAMuB,EAAM,IAAIC,WAAWJ,EAAMrB,QAGjC,IAAK,IAAI0B,EAAI,EAAGC,EAAIN,EAAMrB,OAAQ0B,EAAIC,EAAGD,IACvCF,EAAIE,GAAKL,EAAMO,WAAWF,GAG5B,OAAOG,EAASL,EAClB,CAEOK,QAAAA,GACL,MAAMzB,EAAWL,KAAK+B,cAEtB,IAAIC,EAEJ,GAAI3B,EAAU,CACZ,MAAME,EAAMP,KAAKH,OAAOkB,UAAUV,EAA0BL,KAAKD,SACjEiC,EAAShC,KAAKmB,YAAYZ,EAC5B,CAEA,OAAOyB,CACT,CAEOD,WAAAA,GAML,OAJKrC,GAAqBJ,IACxBI,EAAmBM,KAAKiB,kBAGnBvB,CACT,EA9HIC,EAKG6B,UA4HT"}