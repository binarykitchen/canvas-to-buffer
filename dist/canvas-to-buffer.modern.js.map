{"version":3,"file":"canvas-to-buffer.modern.js","sources":["../src/index.js"],"sourcesContent":["const toBuffer = require('typedarray-to-buffer')\nconst atob = require('atob')\nconst isBrowser =\n  typeof document !== 'undefined' && typeof document.createElement === 'function'\n\n// cached, used only once for browser environments\nvar verifiedImageType\n\nmodule.exports = function (canvas, options = {}) {\n  const self = this\n\n  options.image = options.image ? options.image : {}\n  options.image.types = options.image.types ? options.image.types : []\n\n  // validate some options this class needs\n  if (options.image.types.length > 2) {\n    throw new Error('Too many image types are specified!')\n  } else if (options.image.types.length < 1) {\n    // Set a default image type, just to be robust\n    options.image.types = isBrowser ? ['webp', 'jpeg'] : ['png']\n  }\n\n  if (!options.image.quality) {\n    options.image.quality = 0.5 // default\n  }\n\n  const quality = parseFloat(options.image.quality)\n\n  function composeImageType(index) {\n    var imageType\n\n    if (options.image.types[index]) {\n      imageType = 'image/' + options.image.types[index]\n    }\n\n    return imageType\n  }\n\n  function isMatch(uri, imageType) {\n    const match = uri && uri.match(imageType)\n\n    match && options.debug && options.debug('Image type %s verified', imageType)\n\n    return match\n  }\n\n  // Performance tweak, we do not need a big canvas for finding out the supported image type\n  function getTestCanvas() {\n    var testCanvas\n\n    if (isBrowser) {\n      testCanvas = document.createElement('canvas')\n      testCanvas.width = testCanvas.height = 1\n    } else {\n      testCanvas = canvas\n    }\n\n    return testCanvas\n  }\n\n  function canvasSupportsImageTypeAsync(imageType, cb) {\n    try {\n      const testCanvas = getTestCanvas()\n      testCanvas.toDataURL(imageType, function (err, uri) {\n        if (err) {\n          cb(err)\n        } else {\n          cb(null, isMatch(uri, imageType))\n        }\n      })\n    } catch (exc) {\n      cb(null, false)\n    }\n  }\n\n  function canvasSupportsImageTypeSync(imageType) {\n    var match\n\n    try {\n      const testCanvas = getTestCanvas()\n      const uri = testCanvas.toDataURL && testCanvas.toDataURL(imageType)\n\n      match = isMatch(uri, imageType)\n    } catch (exc) {\n      // Can happen when i.E. a spider is coming. Just be robust here and continue.\n      options.debug &&\n        options.logger.debug(\n          'Failed to call toDataURL() on canvas for image type %s',\n          imageType\n        )\n    }\n\n    return match\n  }\n\n  function verifyImageTypeAsync(imageType, cb) {\n    canvasSupportsImageTypeAsync(imageType, function (err, match) {\n      if (err) {\n        cb(err)\n      } else {\n        if (match) {\n          cb(null, imageType)\n        } else {\n          imageType = composeImageType(1)\n\n          canvasSupportsImageTypeAsync(imageType, function (err, match) {\n            if (err) {\n              cb(err)\n            } else {\n              cb(null, match ? imageType : null)\n            }\n          })\n        }\n      }\n    })\n  }\n\n  function verifyImageTypeSync(imageType) {\n    if (!canvasSupportsImageTypeSync(imageType)) {\n      if (options.image.types[1]) {\n        imageType = composeImageType(1)\n\n        if (!canvasSupportsImageTypeSync(imageType)) {\n          imageType = null\n        }\n      } else {\n        imageType = null\n      }\n    }\n\n    !imageType && options.debug && options.logger.debug('Unable to verify image type')\n\n    return imageType\n  }\n\n  // callbacks are needed for server side tests\n  function verifyImageType(cb) {\n    const imageType = composeImageType(0)\n\n    if (cb) {\n      verifyImageTypeAsync(imageType, cb)\n    } else {\n      return verifyImageTypeSync(imageType)\n    }\n  }\n\n  // this method is proven to be fast, see\n  // http://jsperf.com/data-uri-to-buffer-performance/3\n  function uriToBuffer(uri) {\n    const uriSplitted = uri.split(',')[1]\n    var bytes\n\n    // Beware that the atob function might be a static one for server side tests\n    if (typeof atob === 'function') {\n      bytes = atob(uriSplitted)\n    } else if (typeof self.constructor.atob === 'function') {\n      bytes = self.constructor.atob(uriSplitted)\n    } else {\n      throw new Error('atob function is missing')\n    }\n\n    const arr = new Uint8Array(bytes.length)\n\n    // http://mrale.ph/blog/2014/12/24/array-length-caching.html\n    for (var i = 0, l = bytes.length; i < l; i++) {\n      arr[i] = bytes.charCodeAt(i)\n    }\n\n    return toBuffer(arr)\n  }\n\n  function toBufferSync() {\n    const imageType = self.getImageType()\n    var buffer\n\n    if (imageType) {\n      const uri = canvas.toDataURL(imageType, quality)\n      buffer = uriToBuffer(uri)\n    }\n\n    return buffer\n  }\n\n  function toBufferAsync(cb) {\n    self.getImageType(function (err, imageType) {\n      if (err) {\n        cb(err)\n      } else if (!imageType) {\n        cb()\n      } else {\n        canvas.toDataURL(imageType, function (err, uri) {\n          if (err) {\n            cb(err)\n          } else {\n            cb(null, uriToBuffer(uri))\n          }\n        })\n      }\n    })\n  }\n\n  this.toBuffer = function (cb) {\n    if (cb) {\n      toBufferAsync(cb)\n    } else {\n      return toBufferSync()\n    }\n  }\n\n  // browsers do not need a callback, but tests do\n  this.getImageType = function (cb) {\n    // only run for the first time this constructor is called and\n    // cache result for the next calls\n    if (cb) {\n      if (!verifiedImageType || !isBrowser) {\n        verifyImageType(function (err, newVerifiedImageType) {\n          if (err) {\n            cb(err)\n          } else {\n            verifiedImageType = newVerifiedImageType\n            cb(null, verifiedImageType)\n          }\n        })\n      } else {\n        cb(null, verifiedImageType)\n      }\n    } else {\n      // on the browser side we do cache it for speed\n      if (!verifiedImageType || !isBrowser) {\n        verifiedImageType = verifyImageType()\n      }\n\n      return verifiedImageType\n    }\n  }\n}\n"],"names":["toBuffer","require","atob","isBrowser","document","createElement","verifiedImageType","module","exports","canvas","options","self","this","image","types","length","Error","quality","parseFloat","composeImageType","index","imageType","isMatch","uri","match","debug","getTestCanvas","testCanvas","width","height","canvasSupportsImageTypeAsync","cb","toDataURL","err","exc","canvasSupportsImageTypeSync","logger","verifyImageType","verifyImageTypeSync","verifyImageTypeAsync","uriToBuffer","uriSplitted","split","bytes","constructor","arr","Uint8Array","i","l","charCodeAt","getImageType","buffer","toBufferSync","toBufferAsync","newVerifiedImageType"],"mappings":"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"}